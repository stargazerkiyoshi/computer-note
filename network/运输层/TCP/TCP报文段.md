- TCP segment

### 组成
- [[#首部字段]]
- [[#数据字段]]

### 首部字段
- 典型长度是20byte
##### 源端口号和目的端口号
- 被用于多路复用/分解来自或送到上层应用的数据
- 同[[UDP]]
##### 检验和字段
- checksum field
- 同[[UDP]]
##### 序号字段
- sequence number field
- 32bit
- 用来实现可靠数据传输服服务
- 见[[#序号和确认号]]
##### 确认号字段
- acknowledgment number field
- 32bit
- 用来实现可靠数据传输服务
- 见[[#序号和确认号]]
##### 接收窗口字段
- receive window field
- 16bit
- 用于流量控制
- 指示接收方愿意接受的字节数量
##### 首部长度字段 
- header length field
- 4bit
- 指示了以32bit的字为单位的TCP首部长度。由于首部[[#选项字段]]的原因，所以TCP首部的长度是可变的
- 一般[[#选项字段]]为空，所以TCP首部的典型长度是20byte
##### 选项字段
- 可选、变长
- 用于发送方与接收方协商[[TCP#MSS|MSS]]，
- 或在高速网络环境下，用作窗口调节因子
- 还定义了一个时间戳选项
- 参见[RFC 854]和[RFC 1323]了解细节
##### 标志字段
- flag field
- 6bit
###### ACK 
- 1bit
- 用于指示确认字段中的值是有效的，即 该报文段包括一个对已被成功接收报文段的确
###### RST
- 用于连接建立和拆除
###### SYN
- 用于连接建立和拆除
###### FIN比特
- 用于连接建立和拆除
###### CWR
- 用于明确拥塞通告
###### ECE
- 用于明确拥塞通告
###### PSH
- 当该bit被置位时，指示接收方应立即将数据交给上层
###### URG
- 用于指示报文段里存在着被发送端的上层实体置为**紧急**的数据
- 紧急数据的最后一个字节由[[#紧急数据指针字段]]指出

##### 紧急数据指针字段
- urgent data pointer field
- 16bit
- 当紧急数据存在且给出指向紧急数据尾指针，TCP必须通知接收端的上层实体。
- 实践中，PSH、URG和紧急数据指针并没有使用
### 数据字段
- 包含一块应用数据
- [[TCP#MSS|MSS]]限制了报文段数据字段的最大长度
-  当TCP发送大文件时，将该文件划分成长度为MSS的若干块，最后一块可能不足MSS
-  一般交互式应用通常传送长度小于MSS的数据块

### 序号和确认号
##### 序号
- TCP把数据看成一个无结构的、有序的字节流
- 序号是建立在传送的字节流之上，而不是建立在传送的报文段序列之上。
- —个**报文段的序号(sequence number for a segment)** 是该报文段首字节的字节流（数据字段首字节）序号
- 举例：
	- 主机A的一个进程通过TCP连接向主机B的一个进程发送一个数据流
	- 假设数据流由一个包含500000byte的文件组成
	- [[TCP#MSS|MSS]]为1000byte
	- 主机A的TCP将隐式地对数据流中的每一个字节编号，数据流的首字节编号是0
	- TCP将该数据流构建$500000 / 1000 = 500$个报文段
	- 第一个报文段分配序号0，第二个报文段分配序号1000,第三个报文段分配序号2000...
	- 将每个序号填入到相应TCP报文段首部的序号字段中
![[Pasted image 20220109183903.png]]
##### 确认号
- TCP是全双工的，同一条TCP连接连接的主机A和主机B可能同时在发送和接收数据
- 主机A接收主机B发送的每个报文段中都有一个序号，该序号用于从B流向A的数据。
- **主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号**。
- 例子1：
	- 假设
		1. 主机A已收到了来自主机B的编号为0~535的所有字节
		2. 主机A打算发送一个报文段给主机B
	- 则：主机A在该报文段中的确认号字段填上536，因为它需要主机B的数据流中字节536及之后的所有字节
- 例子2：
	- 假设
		1. 主机A已收到一个来自主机B的包含字节0 ~ 535的报文段和另一个包含字节900〜1000的报文段
		2. 主机A还没有收到字节536 - 899的报文段
	- 则：主机A发送到B的下一个报文段中的确认号字段填上536。因为为了重新构建主机B的数据流，它需要等待字节536 (和其后的字节)。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供**累积确认(cumulative acknowledgment)**
 - 例子3：
 	- 假设同例子2
 	- 问：如何处理失序的报文段？（RFC中没有规定，TCP的编程人员处理）
 	- 答：方法1：[[回退N步（GBN）]]；方法2：[[选择重传（SR）]]（实践中使用的方法）
##### 初始序号的选择
- 一条TCP连接的双方均可**随机**选择初始序号，而不是一定从0开始
- 在两台主机之间传递报文段，当该连接终止时，某些序号可能仍在网络中游荡，当新建立连接后，接收到游荡的报文段，会误认为是新建连接所产生的有效报文段。随机选择初始序号可以减少这种可能性

### 用Telnet学习序号和确认号
- Telnet是一个用于远程登录的应用层协议，运行与TCP上，发送的数据是没有加密的
- 客户端的用户键入的每个字符都会被发送至远程主机
- 远程主机将回送每个字符的副本给客户，并显示在Telnet程序上。这是为了确保客户发送的字符已经被远程主机收到并处理
- 因此，从用户击键到字符显示屏幕上这段时间，每个字符在网络中传输了两次
##### 场景
- 主机A（客户）发起一个与主机B（服务器）的Telnet会话
- 现在键入字符’C‘
- 假设客户和服务器的起始序号分别为42和79
##### TCP报文段过程
- TCP连接建立的没有发送数据之前，客户等待字节79，服务器等待字节42
- 第一个报文段：由客户发送，序号为42，确认号为79，数据字段里包含字符’C‘的ASCII码
- 第二个报文段：由服务器发送，序号为79（数据流中起始序号），确认号为43（表示收到客户发送的序号为42及以前的报文段），数据字段里包含回显的字符’C‘的ASCII码。对客户发送的报文段的确认信息被**捎带（piggybacked）**在返回报文段中
- 第三个报文段：由客户发送，确认号为80，数据字段为空。 唯一目的是确认已从服务器收到数据。确认号不是被捎带的