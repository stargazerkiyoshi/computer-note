- 提供了差错检测功能，报文在传输过程中，其中的比特是否发生了改变
- 发送方的UDP对报文段中的所有16比特字的和进行反码运算, 求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段
- 见 RFC 1071
### 计算例子
##### 发送方计算检验和
1. 初始3个16bit的字
```
0110011001100000 
0101010101010101
1000111100001100
```
2. 前两个16bit的字之和为：
```
0110011001100000 
0101010101010101
----------------
1011101110110101
```
3. 上面的和与第三个字相加
```
1011101110110101 
1000111100001100
----------------
0100101011000010
```
4. 最后一次加法有溢出，它要被回卷
5. 反码运算：0变1，1变0，得到结果`10110101001111`，即为检验和
##### 接收方检验
- 接收方将全部的4个16比特字(包括检验和)加在一起
- 如果结果为`1111111111111111`，则表示没有差错
- 如果结果中有0，则有差错

### 为什么在UDP中需要校验和
- 原因是：
	1. 有些链路层协议提供差错检测，但不能保证源和目的之间的所有链路都提供差错检测
	2. 传输时可能被保证正确传输，但报文段存储在路由器时，可能引入比特差错
- 上述两个问题，使得UDP必须在**端到端基础上**，在运输层提供差错检测。
- 在系统设计中称为**[[#端到端原则]]**

### 端到端原则
- end-end principle
-  因为某种功能(在此时为差错检测)必须基于端到端实现，与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的