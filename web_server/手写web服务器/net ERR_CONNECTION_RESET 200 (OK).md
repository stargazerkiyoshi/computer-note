### stackover
https://stackoverflow.com/questions/58405127/simple-http-server-using-socket-programming-in-c-failed-on-chrome

### 问题
尝试使用 Chrome 连接服务器时，它失败了。出现 GET 错误：“net::ERR_CONNECTION_RESET 200 (OK)”。当我在 DevTool 中检查网络会话时，我看到 Chrome 接收到响应头，显示“HTTP/1.1 200 OK Content-Type: text/html; charset=UTF-8”，但没有看到 HTML 文件

### 答案

此类问题通常发生在服务器关闭连接而客户端仍有未读数据时。在您的情况下，服务器正在关闭连接而不读取来自客户端的请求。但是即使您已经阅读了完整的请求，问题仍然可能发生，因为客户端可能已经发送了多个请求（HTTP 管道）。

HTTP 标准甚至建议如何正确关闭并专门解决您遇到的问题。来自[RFC 7230 第 6.6 节“拆解”](https://www.rfc-editor.org/rfc/rfc7230#section-6.6)：

> 如果服务器立即关闭 TCP 连接，则客户端将无法读取最后的 HTTP 响应的风险很大。如果服务器在完全关闭的连接上收到来自客户端的额外数据，例如客户端在收到服务器响应之前发送的另一个请求，**则服务器的 TCP 堆栈将向客户端发送重置数据包**；不幸的是，重置数据包可能会在客户端的 HTTP 解析器读取和解释之前删除客户端未确认的输入缓冲区。

> **为了避免 TCP 重置问题，服务器通常会分阶段关闭连接**。首先，服务器通过仅关闭读/写连接的写入端来执行半关闭。 **然后服务器继续从连接中读取，直到它收到客户端的相应关闭**，或者直到服务器合理地确定它自己的 TCP 堆栈已收到客户端对包含服务器最后响应的数据包的确认。最后，服务器完全关闭连接。

除此之外：强烈建议（应该在标准中）通过使用`Content-length`标头或使用分块传输编码清楚地标记正文的大小 - 而不是仅仅关闭连接。还强烈建议您通过添加标头向客户端发出信号，表明此连接上不再接受请求`Connection: close`。

总的来说：HTTP 比看几个例子可能想象的要复杂得多。[有一个标准](https://www.rfc-editor.org/rfc/rfc7230)描述了客户端和服务器的行为方式，这个标准很长是有原因的。如果您打算实现自己的 HTTP 堆栈而不是仅仅使用现有的实现，请遵循它。