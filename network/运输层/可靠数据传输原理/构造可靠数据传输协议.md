### rdt1.0
- **底层信道完全可靠**模型下的可靠数据传输协议
- 发送方和接收方通过[[#FSM]]定义
- 发送方和接收方有各自的FSM
- 发送方和接收方都只有一个状态，状态的变迁是从一个状态返回自身
- rdt发送端：通过`rdt_send(data)`**事件**接受来自较高层的数据，通过`make-pkt(data)`动作产生一个包含该数据的分组，并将分组发送到信道中。`rdt_send(data)`事件是由较高层应用调用产生的
- rdt接收端， 通过`rdt_rcv(data)`**事件**从底层信道接收一个分组，通过`extract(packet, data)`**动作**从分组中取岀数据，通过`deliver_data(data)`**动作**将数据上传给较高层。 实际上，`rdt_rcv(packet)`事件是由较低层协议调用产生的
![[Pasted image 20220104224006.png]]
##### rdt1.0总结
- 所有分组是从发送方流向接收方
- 底层完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，不必担心出现差错
- 也假定了接收方接收数据的速率能与发送方发送数据的速率一样快，接收方没有必要请求发送方慢一点

### rdt2.0
- 底层信道的分组中的bit可能受损
- 假设：bit可能物理性的受损；分组仍按照其发送顺序被接收
- 考虑：通过电话口述一件事情，对方（接收者）可能的反应是
	1.  接收者在听到、理解并记下每句话后可能会说“0K”，即**肯定确认(positive acknowledgment)**
	2. 接收者听到一句含糊不清的话时, 他可能要求你重复那句容易误解的话，即**否定确认(negative acknowledgmenl)**
- 这些控制报文可以让发送方知道内容是否被正确接收，是否需要重复
- 基于这样重传机制的可靠数据传输协议称为**自动重传请求(Automatic Repeat reQuest, ARQ)协议**
- 该协议中使用另外三种协议，处理存在比特差错的情况
	1. 差错检测：接收方可以根据检验和判断是否出现了bit差错，类似[[UDP检验和]]，所以协议的分组需要有这一字段
	2. 接收方反馈：接收方提供明确的反馈信息给发送方，如：**肯定确认(ACK)和否定确认(NAK）**，所以协议中的接收方，需要向发送方返回ACK、NAK，1个bit表示
	3. 重传：接收方收到有差错的分组时，发送方需要重新传输该分组

##### 第一版过程
![[Pasted image 20220106215229.png]]
- ACK和NAK不会受损
- 发送方[[#FSM]]：两个状态：等待上层调用（初始态），等待ACK或NAK
- 当发送方处于等待上层调用（初始态）时，通过`rdt_send(data)`**事件**接收来自上层的数据，状态转为等待ACK或NAK，通过`sndpkt=make_pkt(data, checksum)`动作产生一个带有检验和的数据分组，通过 `udt_send(sndpkt)`动作发送该分组
- 当发送方处于等待ACK或NAK时，通过`rdt_rcv(rcvpkt) && isNAK(rcvpkt)`**事件**判断是否是否定确认，如果是，状态不变，通过`udt_send(sndpkt)`动作，再次发送该分组。通过`rdt_rcv(rcvpkt) && isNAK(rcvpkt)`**事件**判断是否是肯定确认，如果是，状态转为等待上层调用（初始态）
- 当发送方处于等待ACK或NAK时，不能继续从上层接收数据，即发生`rdt_send(data)`**事件**，只有离开该状态，才可以。即：停等（stop and wait）协议
- 接收方[[#FSM]]：只有单一状态：等待下层调用
- 接收方在分组到达时：通过下层调用`rdt_rcv(rcvpkt) && corrupt(rcvpkt)`，判断是否分组是否受损，从而选择回答ACK还是NAK

##### 第二版过程
- ACK和NAK会受损，即发送方无法知道接收方是否接收到上次发送的数据
- 考虑解决方法：
	1. 引入新的确认分组：当发送方不理解接收方返回的ACK或NAK时（可能是受损），则发送方发送一个类似于“你说什么”的询问分组，要求接收方再次返回上次返回的内容。问题：发送方发送的“你说什么”也有可能受损，接收方就不知道这是上一次内容分组的还是回复ACK或NAK的分组
	2. 增加足够的检验和比特：使发送方既能检测差错，也能恢复差错。适用于会产生差错但不丢失分组的信道
	3. 只需重传当前数据分组：即在发送方到接收方的信道中引入**冗余分组(duplicate packet)**。问题：接收方无法知道发送方是否接收到ACK还是NAK，这是接收的数据上一次的重传还是的新数据
- 对于上述解决方法3中的问题，解决方法是：让发送方对其数据分组编号，即将发送数据分组的**序号(sequence number)**放在数据分组中，接收方只需要检查序号即可确定是否是一次重传
- 停等协议中，只要1bit序号（0或1），因为只需要区分该分组是重传上一次的还是下次新的分组
- 目前假定信道不丢分组，ACK和NAK分组本身不需要指明它们**要确认的分组序号**。发送方知道所接收到的ACK和NAK分组(无论是否是含糊不清的)是为响应其最近发送的数据分组而生成的。则有rdt2.1
- rdt2.1
	![[Pasted image 20220106222731.png]]
	![[Pasted image 20220106222758.png]]
- rdt2.2中：接收方必须包括由一个ACK报文所确认的分组序号，发送方必须检查接收到的ACK报文中被确认的分组序号
	![[Pasted image 20220106223444.png]]
	![[Pasted image 20220106223504.png]]
- 冗余分组的机制可以使发送方只要没有收到某一序号的ACK报文（不论是因为差错还是别的什么原因）就进行重传上次数据，接收方则可以根据分组的序号知道是不是新的分组

### rdt3.0
- 底层信道中的分组中的bit可能出现差错，分组也可能丢失
- bit差错可以通过[[#rdt2 0]]中讨论的机制解决
- 分组丢失时，可能产生的结果：1. 接收方接收不到发送方发送的分组；2. 发送方接收不到接收方发送的ACK或NAK分组
- 对于结果1：接收方继续等待接收分组，对于结果2：发送方应在接收不到的情况（ACK或NAK分组丢失）下重传上次的分组，但怎么确认确实分组已经丢失？
- 答案是：根据分组的一个往返时间+分组在接收方的处理时间，超过这个时间可以判定为分组丢失，但分组的往返时间是不固定的（排队时间等），怎么检测呢？
- 答案是：不需要检测，只需要在**固定的时间**内没有接收到ACK或NAK即可判定分组丢失，从而进行重传上一次的分组。如果整个往返时间很长，发送方也会重传，接收方只需通过[[#rdt2 0]]中讨论的冗余分组机制，即可处理该次重传的分组
- 所以发送方每次发送数据时需要启动一个**倒计数定时器(countdown timer)**，当在定时范围内收到ACK或NAK分组，则中断定时器，否则重传分组，同时再次启动定时器
![[Pasted image 20220107101132.png]]
- rdt3.0中发送方和接收方发送接收分组的时间图：该过程分组序号在0和1之间交替，所以rdt3.0又称为**比特交替协议(alternating-bit protocol)** 
![[Pasted image 20220107101226.png]]
![[Pasted image 20220107101311.png]]
### FSM
- 有限状态机（Finite-State Machine, FSM）
- 箭头指示从一个状态变迁到另一个状态
- 引起变迁的**事件**显示在表示变迁的横线上方，如果没有，显示Λ（表示缺少事件）
- 事件发生时所采取的**动作**显示在横线下方，如果没有，显示Λ（表示缺少动作）
- **初始状态**用虚线表示