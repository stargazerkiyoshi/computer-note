- Go-Back-N，GBN
- 也被称为**滑动窗口协议（sliding-window protocol）**
- [[流水线可靠数据传输协议#流水线|流水线]]中未确认的分组数不能超过某个最大允许数N
- 出现丢失和时延过长分组时发送方的行为

### GBN协议的序号范围
- 最大允许数N：未确认的分组数不能超过N（主要是限制发送方无限制的发送分组）
- [[#基序号]]和[[#下一个序号]] 可将序号范围$[0, \infty]$分割成4段
- 序号段为$[0, base - 1 ]$：已发送并被确认的分组
- 序号段为$[base, nextseqnum - 1 ]$：已发送但未被确认的分组
- 序号段为$[nextseqnum, base + N - 1]$：其中的序号能用于要被立即发送的分组
- 序号段为$[base + N, \infty]$：不可使用，只有当未被确认的分组（$[base, nextseqnum - 1 ]$）被确认后才可使用
![[Pasted image 20220109113620.png]]
- 随着协议的运行，[[#窗口]]会在整个序号范围内向前滑动
- 所以该协议又叫滑动窗口协议
##### 基序号
- base
- 最早的、未确认的分组的序号
##### 下一个序号
- nextseqnum
- 最小的、未使用的序号(即下一个待发分组的序号)
##### 窗口
- 已被发送但还未确认的分组的序号范围可以被看作是长度为N的窗口
- N常被称为**窗口长度(window size)**

### 分组序号
- 分组中的序号是：分组首部的固定长度的字段
- 如果分组序号字段的bit长度为$k$，则序号范围为$[0, 2^k-1]$
- 涉及序号的运算必须使用$2^k$模运算，即序号空间是一个$2^k$的环序号$2^k-1$紧接着序号0
- [[构造可靠数据传输协议#rdt3.0|rdt3.0]]有1个bit的序号字段，序号范围为$[0,1]$
- TCP有一个32bit的序号字段，该序号是按字节流中的字节进行计数，而不是按分组计数

###  基于ACK、无NAK的GBN协议的扩展FSM描述
##### 发送方必须响应的事件
1. 上层的调用
	- 调用rdt.send()时，首先检查[[#窗口]]是否已满，即已发送但未被确认的分组是否为N个
	- 如果未满：则产生分组并发送，同时更新相应变量
	- 如果已满：则通知上层已满，稍后再试。实际中可能缓存该数据，或同步到上层一个窗口是否已满的flag，只有窗口未满时，上层才调用rdt.send()
2. 收到一个ACK
	- 序号为n的分组的确认采取[[#累积确认]]的方式
3. 超时事件
	- 使用定时器
	- 如果出现超时，发送方重传所有已发送但未被确认的分组
	- 发送一个分组（之前的分组都已经被确认），同时开启一个定时器，当该分组没有被确认时，定时器一直计时
	- 此时如果收到一个刚才发送的分组对应的ACK，但仍有已发送但未被确认的分组，则重启定时器。如果没有已发送但未被确认的分组，停止定时器
![[Pasted image 20220109123953.png]]
##### 接收方动作
- 使用[[#累积确认]]
- 如果序号为n的分组被正确接收，且上次交付给上层的数据是序号为n-1的分组（**按序**），则为分组n发送一个ACK，并将该分组中的数据交付到上层
- 其他情况，接收方丢弃该分组，并为最近**按序**接收的分组重新发送ACK
- 自然的，如果分组k已接收并交付，则所有序号比k小的分组也已经交付
![[Pasted image 20220109124012.png]]
##### 累积确认
- cumulative acknowledgment
- 接收方已正确接收序号为n的以及小于n的所有分组
##### 扩展FSM
- [[构造可靠数据传输协议#FSM|FSM]]描述的一种
- 在描述中增加了
	1. 变量（编程语言中的变量）
	2. 对变量的操作
	3. 与变量有关的条件动作
### GBN的优缺点
##### 优点
- 接收缓存简单，不需要缓存任何失序分组。接收方中：当分组n丢失但分组n+1到达（失序），不需要缓存分组n+1，只需直接丢弃，因为发送方会重传分组n之后的所有分组
- 接收方只需要维护下一个按序接收的分组的序号。该值保存在expectedseqnum变量中
##### 缺点
- 发送方必须维护窗口的上下边界及nextseqnum在该窗口中的位置
- 重传n之后的所有分组，意味着，n之后分组也有可能丢失出错，从而导致更多的重传

### 运行实例
![[Pasted image 20220109125223.png]]

### 基于事件的编程
- event-based programming
- 每个过程实现了在响应各种可能岀现的事件时要采取的动作
- 这些过程要么被的其他过程调用，要么作为一次中断的结果
- 发送方事件包括：
	1. 上层调用rdt_send()
	2. 定时器中断
	3. 报文到达时，下层调用rdt_rcv()

### GBN性能问题
- 当窗口长度和带宽时延积都很大，同时流水线中有很多分组时，其中某个分组的差错就会重传大量分组，而很多分组可能不需要重传
- 当信道差错率越大，重传的分组越多

### 解决GBN性能问题
- 使用[[选择重传（SR）]]