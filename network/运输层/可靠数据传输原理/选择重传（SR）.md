- 为了解决[[回退N步（GBN）#GBN性能问题|GBN性能问题]]]
- 仅重传那些怀疑在接收方出错(即丢失或受损)的分组，避免不必要的重传
-  接收方逐个地确认正确接收的分组

### SR的序号空间
- 窗口长度N：限制流水线中未完成、未被确认的分组数
- 发送方已经收到了对窗口中某些序号的分组的ACK
- 接收方所做的动作简介：
	1. 将确认一个正确收到的分组，不管该分组是否失序
	2. 失序的分组将被缓存，直到所有丢失的分组（序号更小）都正确接收
	3. 将这批分组按序交付到上层
![[Pasted image 20220109130913.png]]

### 发送方的动作
1. 从上层收到数据
	- 检查下一个序号是否在窗口内。如果是：生成分组并发送，否则和[[回退N步（GBN）]]类似
2. 超时
	- 某一个分组发生超时后，只重传该分组，所以每个分组都要有自己的定时器。可以使用**单个硬件定时器模拟多个逻辑定时**
3. 收到ACK
	- ACK中的分组序号在窗口内，则发送方将该被确认的分组标记为已接收
	- 如果分组序号等于send_base，窗口基序号向前移动到**具有最小序号的、未确认的分组**处
	- 窗口移动了且有序号落在窗口内的未发送分组，则发送这些分组
### 接收方的动作
1. 序号在$[rcv_base, rcv_base+N-1]$内的分组被正确接收
	-  收到的分组序号在接收方的窗口内，一个选择ACK被回送给发送方
	- 如果该分组以前没收到过，则缓存该分组
	- 如果该分组的序号等于接收窗口的基序号rcv_base，则该分组以及以前缓存的分组、序号连续的分组交付给上层，即：从序号为rcv_base的分组，往后数已经缓存的、连续序号的分组，直到未缓存分组的序号为止，将这一块序号连续的分组交付给上层
	- 然后，接收窗口向前移动，rcv_base移动到未缓存分组的序号中
2. 序号在$[rcv_base-N, rcv_base-1]$内的分组被正确收到
	- 必须产生一个ACK，即使该分组是接收方以前已确认过的分组
3. 其他情况。忽略分组

### 例子
![[Pasted image 20220109135311.png]]
### 接收方和发送方的窗口并不总是一致
- 发送方的$send_base$小于接收方$rcv_base$
- 当$send_base$的分组丢失，或发送方没有收到该分组的ACK，则发送方会重传该分组
- 在[[#接收方的动作]]2中，接收方收到一个小于序号$rcv_base$的分组，不能忽略，一定要产生ACK返回
- 否则，发送方永远不会收到$send_base$分组的ACK，即发送方窗口永远不会向前滑动
- 发送方和接收方看到结果的不一致

### 窗口太大导致失效
- 4个分组序号0、1、2、3的有限序号范围
- 窗口长度：3
#### 例子1
- 发送方发送3个分组0、1、2，接收方成功接收并确认分组，确认ACK0、1、2全部丢失
- 此时：
	1. 发送方：窗口不变，准备重传分组0、1、2
	2. 接收方：窗口改变，准备接收序号3、0、1（其实是第4、5、6号）分组
- 发送方重传分组0、1、2，接收方缓存分组0、1，并等待分组3到达，完全乱了
![[Pasted image 20220109141227.png]]

##### 例子2
![[Pasted image 20220109141857.png]]

##### 总结
- 对于接收方，不知道发送方发送的是新的分组还是重传的分组

### 解决窗口太大导致失效
- 窗口长度必须小于或等于序号空间大小的一半
- 待证明