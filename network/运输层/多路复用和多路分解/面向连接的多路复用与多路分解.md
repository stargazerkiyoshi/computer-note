-  TCP套接字是由一个**四元组(源 IP地址, 源端口号，目的IP地址，目的端口号)**标识的
-  当报文段到达主机时，主机使用该四元组将报文段定向（分解）到相应TCP套接字中
-  源IP或端口不同，即使目的地址和端口相同，将会定向到不同套接字中
-  除非，报文段携带了初始创建连接的请求

### 过程
- 见[[TCP套接字]]
1.  TCP服务器应用程序有一个“欢迎套接字”，在端口号12000上等待TCP客
户的**连接建立**请求
2. TCP客户创建一个套接字并发送**连接建立**请求报文段
```python
clientsocket = socket(AF_INET, SOCK_STREAM) clientsocket.connect((serverNamer12000))
```
3. 一条**连接建立**请求是一个TCP报文段，其中包含：1. 目的端口号为12000；2.TCP首部的“连接建立位”置位；3. 客户选择的源端口号
4. 当服务器运输层接收该请求报文段后，则将报文段定位到相应的服务器进程，发现该进程正在端口号12000等待接受连接
5. 然后，该服务器进程则创建一个新的套接字：
```python
connectionSocketr addr = serversocket.accept()
```
6. 新创建的连接套接字通过**连接请求**报文段中的4个值标识。即：1. 源端口号；2. 源主机IP地址；3. 目的端口号；4. 服务器自己的IP地址
7. 所有后续到达的报文段，如果源端口号、源主机IP地址、目的端口号和目的IP地址都与这4个值匹配，则被定向（分解）到该套接字
8. TCP连接完成，客户和服务器可以相互发送数据了

### 例子
![[Pasted image 20220103191038.png]]

### Web服务器与TCP
- Web服务器通常根据源IP地址和源端口号区分不同客户
- 通常一个进程中可以有多个套接字，每个套接字在一个线程里
- HTTP持续连接，连接期间，通过同一个服务器套接字交换报文
- 非持续连接，每一次交换报文需要关闭上次的套接字，重新创建套接字。造成资源浪费