## 第1篇
- [原文](https://developers.google.com/web/updates/2018/09/inside-browser-part1)，[译文](https://juejin.cn/post/6844903679389073415)

### 计算机体系结构
- 底层是机器硬件，中间层是操作系统，顶层是应用程序。
##### CPU
- 计算机的核心是**中央处理器（Central Processing Unit，CPU）**
- CPU 大多是单芯片，但可以有多个核，每一核相当于一个独立的CPU
##### GPU
- **图形处理器（Graphics Processing Unit，GPU）**
- 处理跨内核的简单任务
- 最初是为解决图形而开发的
##### 操作系统
- 提供某种机制使应用在 CPU 和 GPU 上运行。

### 进程与线程
##### 进程
- 进程可以被描述为是一个应用的执行程序，独立的
- 有一个或多个[[#线程]]（还是可能有？？？）
- 有私有内存空间
- 进程之间的通信通过**进程间通信（IPC）**
##### 线程
- 线程存在于[[#进程]]并执行程序任意部分

### 应用程序关于进程的架构
##### 单进程多线程
- 考虑执行应用程序的过程
- 应用启动时会创建一个[[#进程]]（其中可能包括一个或多个[[#线程]]）
- [[#操作系统]]为进程提供了一个可以使用的“一块”内存，所有应用程序状态都保存在该私有内存空间中
- 关闭应用时，会释放进程和内存

##### 多进程多线程
- 以[[#单进程多线程]]为基础
- 应用启动时会创建多个[[#进程]]（每一个其中都可能包括一个或多个[[#线程]]），执行不同的任务
- 内存会分给这些进程
- 进程之间通过IPC通信
- 某一个进程失去响应，可以重新启动，且不会影响其他部分的进程

### 浏览器架构
- 浏览器作为应用程序的一种，也在[[#应用程序关于进程的架构|上述架构]]范围内
- [[#应用程序关于进程的架构|两种架构]]都有，并无标准
- 以下使用最近Chrome浏览器讨论
- **浏览器进程**。协调处理应用其它模块任务的进程，在顶部
- **渲染进程**。创建了多个渲染进程并分配给了每个标签页
- 直到最近，Chrome 在可能的情况下给每个标签页分配一个进程。而现在它试图给每个站点分配一个进程，包括 iframe（查看[[#站点隔离]]）
![[chrome浏览器的多进程架构示意图.png]]

### Chrome浏览器中的进程控制着哪些
##### 基本进程
 1. 浏览器进程
 	- 控制：应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及作为web浏览器不可见的部分，如网络请求与文件访问。
	- 包含线程：UI 线程（绘制浏览器按钮和输入栏）、网络线程（处理网络栈以获取网络数据）、存储线程（控制文件访问）等
 2. 渲染进程
     - 控制：标签页内网站展示
 3. 插件进程
	 - 控制：站点使用的任意插件，如 Flash
 4. GPU进程
 	控制：处理独立于其它进程的 GPU 任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用（即超出浏览器界面的其他应用程序）的请求并绘制在相同表面（同一桌面）。
 ![[chrome浏览器不同进程控制区域.png]]
 ##### 更多进程
- 扩展进程与应用进程
##### 查看chrome浏览器进程的方法
- 浏览器右上角菜单->更多工具->任务管理器
![[实际查看进程的例子.png]]

### Chrome多进程架构的优点
- 每个标签页都有自己的独立的渲染进程，当一个进程失去响应，其他标签仍可以正常运行。单个进程则所有标签不可用。
- 安全性与沙箱化。[[#操作系统]]提供了限制进程权限的方法，浏览器就可以用沙箱保护某些特定功能的进程。如：限制那些处理任意用户输入的进程(如渲染器进程)，对任意文件的访问。

### Chrome多进程架构的内存
- 每个进程的内存通常包含公共基础设施的拷贝(如 V8，JavaScript 引擎)，使用了更多的内存
- 同一进程中的线程，无法共享这些拷贝
- 为节省内存，Chrome 对可加速的内存数量进行了限制，具体限制数值依设备可提供的内存与 CPU 能力而定，运行达到限制时，会开始在**同一站点**的**不同标签页**上运行**同一进程**。
- 为节省更多内存，Chrome 转变为将每一模块作为一个服务来运行，从而实现进程的拆解或聚合。
   1. 当运行在强力硬件上时，将每个服务分解到不同进程中，提升稳定性。
   2. 当运行在资源有限的设备上时，将服务聚合到一个进程中，节省了内存占用。

### 站点隔离
- Chrome的一个功能
- 站点隔离为每个 iframe 运行一个单独的渲染进程，
- 允许跨站点 iframe 运行在一个单独的渲染进程，在不同站点中共享内存
	a.com的一个页面中有b.com和c.com两个iframe，每个iframe有一个单独的渲染进程，加上a.com的渲染进程，共有3个渲染进程
![[跨站点的iframe渲染进程示意图.png]]
- 重要里程碑。 从根本上改变了 iframe 的通信方式。一个页面中有iframe，当打开开发者工具时，需要处理该iframe的渲染进程，以使它看起来无缝。运行一个简单的 Ctrl + F 来查找页面中的一个单词，也意味着在不同的渲染器进程中进行搜索。

### 同源策略
-  web 的核心安全模型
-  确保站点（如：a.com）在未得到其它站点（如：b.com）许可的情况下不能获取其（即b.com）数据
-  如果两个URL的协议、主机名、端口（如果有）都相同的话，则这两个 URL 是**同源**
	详情查看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)
-  安全攻击的一个主要目标就是绕过同源策略。[[#进程]]隔离是分离站点的最高效手段。（查看[Meltdown and Spectre](https://developers.google.com/web/updates/2018/02/meltdown-spectre)）
-  Chrome 67 版本后，桌面版 Chrome 都默认开启了[[#站点隔离]]

---------------

## 第2篇
- [原文](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part2 "https://developers.google.com/web/updates/2018/09/inside-browser-part2")
- [译文](https://juejin.cn/post/6844903692890537992)

### 进程和线程如何进行通信以展示网站
- 用网络浏览作为用例：在浏览器中输入 URL，然后浏览器从互联网获取数据并显示一个页面。即用户请求站点和浏览器准备渲染页面部分 —— 导航。

### 以浏览器进程为开始
- 浏览器Tab之外的区域由[[#基本进程|浏览器进程]]控制
- 当在地址栏输入URL时，将由UI线程处理该地址
![[浏览器进程中的线程.png]]
### 一次简单的导航过程
##### 1. 处理输入
 - 涉及UI线程
 - UI 线程需要解析是搜索关键字还是访问网站的URL，从而决定把请求发送到搜索引擎，还是要请求的网站。

 ![[1.输入搜索.png]]
##### 2. 开始导航
- 涉及UI线程和网络线程
- 按下Enter
- UI 线程启用网络线程
- 网络线程会通过适当的协议，如 DNS 查找和为请求建立 TLS 连接。（具体过程[[HTTP]]）
- 加载动画会显示在标签页的一角
- 网络线程可能收到像 HTTP 301 那样的服务器重定向头。
- 这种情况下，网络线程会告诉 UI 线程，服务器正在请求重定向。然后，另一个 URL 请求会被启动。
![[2.开始导航.png]]
##### 3. 读取响应
- 涉及网络线程、渲染进程、下载管理器
- 一旦收到响应主体（payload），网络线程会在必要时查看数据流的前几个字节（header）
-  Content-Type字段（在响应报文header中）会声明数据的类型，但是它有可能会丢失或错误，所以就有了 [MIME 类型嗅探](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types")解决这个问题。处理该问题比较棘手。
	![[3.响应报文.png]]
- 如果响应是一个 HTML 文件，那么会把数据传给渲染进程
- 如果是一个压缩文件或是其他文件（即下载请求），那么将数据传递给下载管理器
- 此时会进行的检查
	1.  [SafeBrowsing](https://safebrowsing.google.com/") 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。
	2. [Cross Origin Read Blocking（**CORB**）](https://www.chromium.org/Home/chromium-security/corb-for-developers)检查。确保敏感的跨域数据不被传给渲染进程。如果发生了会在控制台抛出错误（查看[[#同源策略]]）
 - 所有的检查执行完毕，并且网络线程确信浏览器会导航到请求的站点，网络线程会告诉 UI 线程所有的**数据准备完毕**
![[3.1响应解析.png]]
##### 4. 查找渲染进程
- 涉及网络线程、UI线程
- 由UI 线程寻找渲染进程去开始渲染 web 页面
- 优化策略：因为网络请求有延时，所以当UI线程把请求发送给网络线程时，可以并行地寻找或开启一个渲染进程。正常情况，数据响应到达时可以直接使用该待命的进程。异常情况（重定向等），也可重新开启另一个渲染进程
- **渲染进程准备完毕**
![[4.查找渲染进程.png]]
##### 5. 提交导航
- 涉及浏览器进程、渲染进程
- 数据和渲染进程已经就绪
- 浏览器进程会发送一个 IPC（进程间通信）到渲染进程去提交导航，并传递数据流
- 渲染进程保持接收 HTML 数据
- 渲染进程提交的确认消息到浏览器进程，
- 浏览器进程导航完毕
- 文档加载解析开始
- 此时浏览器发生的现象：
	1. 地址栏已更新，安全指示器和站点设置 UI 会反映新页面的站点信息。
	2. 此标签页的 session 历史记录会被更新，所以前进/后退按钮会走向刚导航过的站点。当关闭标签页或窗口，为了优化 tab/session 的还原，session 历史被保存在硬盘上
![[5.提交导航.png]]
##### 额外的步骤：初始加载页面
- 导航提交完毕，
- 渲染进程开始加载资源和渲染页面。（查看[[#第3篇]]）
- 渲染进程渲染完成，会发送一个 IPC 返回给浏览器进程（页面中所有的 frame 的 `onload` 事件**已经触发和执行完毕后**发生）。
- 此时，UI 线程停止标签页上的加载动画
- 此后，客户端 JavaScript 仍然可以加载额外的资源并且渲染新视图
![[额外步骤.png]]

### 再次导航到另一个站点
##### 由浏览器进程发起再次导航
- 浏览器已渲染完成页面，此时在地址栏输入URL并Enter（即新的导航请求到来时）
- 浏览器进程询问当前渲染进程，检查当前已渲染的站点是否绑定了 [[#beforeunload事件]]
- 执行完beforeunload事件后，且确定要导航
- 执行[[#一次简单的导航过程]]的步骤
##### 由渲染进程发起再次导航
- 用户点击一个链接或客户端 JavaScript 运行 `window.location = "https://newsite.com"`时（渲染进程启动导航）
- 渲染进程会先检查 `beforeunload` 事件处理程序
- 执行完beforeunload事件后，且确定要导航
- 将导航请求发送到浏览器进程
- 执行[[#一次简单的导航过程]]的步骤
![[再次导航之前的询问.png]]
##### 新旧站点不同时
- 调用一个独立的渲染进程处理新导航
- 同时保持当前的渲染进程来处理类似 `unload` 的事件（查看[页面生命周期概览](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events)，[页面声明周期 API](https://developers.google.com/web/updates/2018/07/page-lifecycle-api) ）
![[新旧导航不同时.png]]
##### beforeunload事件
- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/beforeunload_event)
- 在试图导航离开或关闭标签页时可以使用它询问是否要离开。如：警告用户可能会丢失在页面上输入的数据
- 仅在需要时添加此事件处理程序。因为该检查程序需要在导航开始之前执行，所以会产生导航的延迟

###  Service Worker
##### 概况
- 对导航过程的一个新变动
- 是一种在应用代码中编写网络代理的方法（页面中的script标签），开发者更好地控制本地缓存内容以及何时从网络获取新数据。
- 如果将 service worker 设置为从缓存加载页面，则无需从网络请求数据。
##### 导航过程的变动
- Service Worker 是在渲染进程中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 service worker
- 注册一个 service worker，保持 service worker 的作用域作为一个引用（查看 [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) ）。
- 当一个导航发生时，网络线程用已注册的 service worker 作用域来检查域名
- 如果已经为该 URL 注册了一个 service worker，则UI 线程找一个渲染线程来执行 service worker 的代码。
- service worker 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。
![[查找service worker作用域.png]]
![[UI进程处理service worker.png]]

### 导航预加载
- [详情](https://developers.google.com/web/updates/2017/02/navigation-preload)
- 如果 service worker 决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。通过与 service worker 启动并行加载资源来加速此过程的机制。
- 它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。
![[导航预加载.png]]