- 定义在RFC 793、RFC 1122、RFC 1323、 RFC 2018 以及 RFC 2581 中

### TCP连接
- 面向连接的（connection-oriented）
- 发送数据前先握手：互相发送一些预备报文段，建立确保数据传输的参数
- 连接的双方需要**初始化**与TCP连接相关的**状态量**
- 该连接是一条逻辑连接，状态仅保留在端系统的TCP程序中
- TCP协议只在端系统中运行，中间网络不会维持TCP连接状态，它们看到的是数据报
- 当一台主机进程A与另一台主机进程B存在一条TCP连接，应用数据就可以互相传递了
- 连接是**点对点（point-to-point）**的
- TCP中不存在**多播**

### 建立TCP连接
- 客户应用进程通知客户运输层发起对某个服务器进程的连接
```python
clientsocket.connect((serverName,serverPort))
```
- 客户TCP和服务器TCP开始建立TCP连接
- 连接过程称为[[#三次握手]]
##### 客户进程
- 发起连接的进程
##### 服务器进程
- 等待连接的进程
#####  三次握手
- 过程
	1. 客户首先发送一个特殊的TCP报文段
	2. 服务器用另一个特殊的TCP报文段来响应
	3. 客户再用第三个特殊报文段作为响应
- 前两个报文段不承载**有效载荷**，即不包含应用层数据；第三个报文段可以承载有效载荷

### 发送TCP报文段
- 客户进程通过套接字向TCP传递应用层数据
- 数据传递到TCP后，由TCP全权控制数据如何发送
- TCP将数据存入的[[#发送缓存]]
- TCP会不时从[[#发送缓存]]里取出一块数据，并将数据传递到网络层
- 规范[RFC 793]中没有明确说明TCP应何时从发送缓存里的数据，只是描述为“TCP应该在它方便的时候以报文段的形式发送数据”
- TCP从缓存中取出并放入报文段中的数据数量，受限于[[#MSS]]
- TCP为每个数据搭配TCP首部形成多个**[[TCP报文段]]**
- 向下层网络层传递，由网络层封装层IP数据报后发往目的地
- 目的地接收到一个报文段后，该报文段被放入该TCP连接的[[#接收缓存]]
![[Pasted image 20220109171153.png]]
##### 发送缓存
- send buffer
- 发送端TCP缓存
- [[#三次握手]]期间设置的缓存之一
- 存储应用层数据
##### 接收缓存
- 接收端TCP缓存
##### MSS
- 最大报文段长度、 Maximum Segment Size
- 是指报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度
- 通常根据最初确定的、由“本地发送主机”发送的、最大链路层帧长度（即[[#MTU]]）来设置
- 设置时，要保证一个TCP报文段(封装在一个IP数据报中)加上TCP/IP首部长度(约40byte)，适合单个链路层帧
- MSS的典型值为1460byte（[[#MTU|MTU典型值减去40byte]]）
- 已经有多种发现路径MTU的方法，并基于[[#路径MTU]]值设置MSS
- 
##### MTU
- 最大传输单元, Maximum Transmission Unit
- 典型值：以太网和PPP链路层协议都具有1500byte的MTU

##### 路径MTU
- 能在从源到目的地的所有链路上发送的最大链路层帧[RFC 1191]