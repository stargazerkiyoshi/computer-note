
### API
window.atob() // 对base64编码过的字符串进行解码  
window.btoa() // 对ASCII编码的字符串进行base64编码（不支持汉字，汉字可通过URIencode预处理后再编码）

### 应用
1.  前端将较小的icon编码为base64直接在文档中加载，减少http请求
2.  电子邮件传输二进制文件时，通常用base64编码后再传
注意：
	1.  base64编码后的数据量是要比编码前大的，所以base64不能用于减少数据量。
	2.  base64不能用于加密数据，即使使用私有的索引表也是不安全的。

### 性能：
优点：减少请求数量。将外部资源（e.g. 图片）直接嵌入到使用它的文本（e.g.样式表）中，所有资源（样式表或图片）能够在同一时间到达
缺点：
	1. 样式表体积变大且不易压缩。base64嵌入多了，gzip无法处理压缩base64，导致样式表很大。由于图片不阻止渲染，样式会，**非阻塞资源变成了阻塞资源**
	2. 将所有资源都下载。响应式样式表中：url的方式只会下载必要的资源，而base64的方式会将所有资源都下载
	3. 缓存被迫所有资源都下载。通过耦合字体，图片和样式，它们都受同样的规则控制。这意味着即使我们只是随便改变CSS的一个hex值（可能最多就六个字节的数据更改），就需要重新下载几百K的样式，图片和字体。Base64编码意味着我们没办法根据自己的变化来单独缓存内容，也意味着无论是否有改变都需要缓存不变的信息

总结：
-   Base64增加了文件的大小但我们却无法有效压缩（e.g.Gzip）。而这种行为会延迟加载，阻塞渲染。    
-   Base64把非关键资源（e.g.图片，字体）放到关键资源（e.g.样式表）中。这意味着在这种特殊情况下，在我们开始渲染页面之前，相比起68K的CSS，我们需要下载超过3.4倍的内容。我们白白的让用户等待那些他们原本并不需要等待的内容！
-   Base64强制所有内容都需要下载，即使它们根本就不会被用到。这是一种浪费，而且还发生在我们的关键资源中。
-   Base64限制了我们独立缓存的能力；我们的图片和字体被样式绑定，反之亦然

样式表大的缺点：在构建CSSOM之前无法构造渲染树，在所有样式表加载完、解压缩和解析之前无法构造CSSOM。CSS才是瓶颈。