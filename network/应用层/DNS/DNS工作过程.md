### 概况
当用户主机上的某些应用程序需要将[[DNS#主机名|主机名]]转换为[[DNS#IP地址|IP地址]]，会发生下列过程：
1. 用户主机上的**应用程序**调用同一主机上的**DNS客户端**，并指明要转换的主机名（UNIX上的gethostbyname()函数）
2. **DNS客户端**接收主机名后，向**网络中心**发送DNS查询报文。（请求和回答的报文都使用UDP数据报，经53端口发送）
3. 经过毫秒或秒的时延后，**DNS客户端**接收到回答报文，里面有该主机名的IP地址映射
4. 映射结果传递到**应用程序**

### 复杂的内部设计
- 由：分布于全球的大量DNS服务器、定义了DNS服务器与查询主机通信方式的应用层协议组成
- 设计方式：1. 集中式 2. 分布式

### 集中式
- 只使用一个DNS服务器。该服务器包含所有主机名和IP地址的映射。
- 问题：
	1. 单点故障（a single point of failure）。如果该服务器崩溃，则整个internet将瘫痪
	2. 通信容量（traffic volume）。要处理**所有的**DNS查询。
	3. 远距离的集中式数据库（distant centralized database）。不可能临近所有查询客户。导致严重的时延
	4. 维护（maintenance）。为所有主机保留记录。中央数据库庞大，且为每个新添加的主机频繁更新
- 总之：完全没有扩展能力

### 分布式
##### DNS服务器层次结构
- 分布在全世界，没有一台DNS有所有主机的映射，所有映射分布在左右DNS服务器上
- 以层次方式组织起来
- 3种类型的DNS服务器：[[#根DNS服务器]]、[[#顶级域DNS服务器]]、[[#权威DNS服务器]]
![[dns层次结构.png]]
###### 根DNS服务器
- 提供[[#顶级域DNS服务器|TLD服务器]]的IP地址
- 由13个不同的组织管理。
- 可以在 [Root Severs 2016] 中查询所有清单
###### 顶级域DNS服务器
- 顶级域（Top-level Domain, TLD）DNS服务器，TLD服务器
- 提供[[#权威DNS服务器]]的IP地址
- 每个顶级域名（com,net等）和国家域名（cn，uk等）都有TLD服务器
- [ TLD list 2016 ]中查询所有清单
###### 权威DNS服务器
- 提供主机名对应的IP地址
- 一般是提供DNS服务某个机构的DNS服务器
- 某个组织想在internet上提供公共可访问的主机，必须提供一个记录（即主机名和映射的IP地址）
- 该记录保存在权威DNS服务器上
- 可以自由选择权威DNS服务器，有些是收费的，有些自己搭建

###### 粗略的查找过程
假设一个DNS客户要获取主机名`www.amazon.com`的IP地址，将发生下列过程
1. **客户**先与**[[#根DNS服务器|根服务器]]**之一联系，返回顶级域名`com`的[[#顶级域DNS服务器|TLD服务器]]的IP地址
2. **客户**再与上述**[[#顶级域DNS服务器|TLD服务器]]**之一联系。返回`amazon.com`的[[#权威DNS服务器|权威服务器]]的IP地址
3. **客户**最后与上述**[[#权威DNS服务器|权威服务器]]**之一联系，返回`www.amazon.com`的IP地址

###### 本地DNS服务器
- local DNS server
- 每个[[ISP]]都有一台本地DNS服务器（默认名字服务器）
- 本地DNS服务器一般**邻近**主机（同一局域网、不超过几台路由器）
- 当主机与ISP连接，ISP提供一台主机的IP地址，该主机有**一台或多台本地DNS服务器**的IP地址（通过DHCP）
- 当主机发出DNS请求时，先发往本地DNS服务器，由它代理，转发到[[#DNS服务器层次结构]]中

###### 详细一些的查找过程
- 假设：
1. 纽约大学的主机 `cse.nyu.edu`想知道主机 `gaia.cs.umass.edu`的IP地址
2. 主机 `cse.nyu.edu`的本地DNS服务器为主机 `dns.nyu.edu`
3. `gaia.cs.umass.edu`的权威DNS服务器为`dns.umass.edu`
- 则发生下列过程
1. **主机** `cse.nyu.edu`向它的**本地DNS服务器** `dns.nyu.edu`发送DNS查询报文，报文中包含主机名`gaia.cs.umass.edu`
2. **本地DNS服务器 **将该报文转发到**[[#根DNS服务器]]**
3. **根DNS服务器**看到`edu`的前缀，返回负责edu的[[#顶级域DNS服务器|TLD服务器]]的IP地址列表，给**本地DNS服务器**
4. **本地DNS服务器 **将该报文发送到上述**TLD服务器**之一
5. **TLD服务器**看到`umass.edu`前缀，返回`umass.edu`的[[#权威DNS服务器]]的IP地址（即 `dns.umass.edu`），给**本地DNS服务器**
6. **本地DNS服务器**发送报文到**权威DNS服务器**`dns.umass.edu`
7. **权威DNS服务器**`dns.umass.edu`返回`gaia.cs.umass.edu`的IP地址
8. **本地DNS服务器**返回该IP地址到**主机**
![[dns查找过程1.png]]
- 总共发送8份DNS报文：4份查询，4份回答。可以[[#DNS缓存]]，减少流量

###### TLD服务器并不总是知道主机的权威DNS服务器的IP地址
- 中间可能有很多权威DNS，按层次组织，一级查找另一级

###### [[#详细一些的查找过程|上述过程]]的查找方式
1. 递归查找
	- recursive query
	- **主机** `cse.nyu.edu`向它的**本地DNS服务器** `dns.nyu.edu`发送DNS查询报文是递归查找
	- 因为该查询以自己的名义请求DNS来获得该映射（？？？）
	- 
2. 迭代查找
	- iterative query
	- 之后的查找都是迭代查找
	- 因为所有的回答都是直接返回给本地DNS服务器
- 理论中，两种都可以![[dns递归查找.png]]
- 实践中，请求主机到本地DNS服务器的查询是递归的，其余的是迭代的

##### DNS缓存
- DNS caching
- 改善DNS时延、请求数量
- 原理：当某个DNS服务器接收一个DNS回答时，能将该映射缓存在本地存储器中
- 缓存并不是永久的，因为映射可能会变，一段时间（通常设置为2天）将丢弃缓存
- 当某个DNS请求某个主机名与IP地址的映射过后，另一个类似的请求（相同主机名），就可以直接使用缓存里的映射，而不用在层次结构中继续请求